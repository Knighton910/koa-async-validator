const chai = require('chai');

const { expect } = chai;

// Helper to handle resolving tests async
function verify(done, f) {
  try {
    const test = f();
    if (test && test.then) {
      test
        .then(() => {
          done();
        })
        .catch(err => {
          done(err);
        });
    } else {
      done();
    }
  } catch (e) {
    done(e);
  }
}

describe('#withMessage()', () => {
  describe('on async validators', () => {
    before(() => {
      delete require.cache[require.resolve('../src/koa_validator')];
    });

    it('should not affect a passing validation', done => {
      const validator = require('../src/koa_validator')({ // eslint-disable-line
        customValidators: {
          test() {
            // A dummy passing validator
            return new Promise(resolve => {
              resolve(true);
            });
          },
        },
      });

      const ctx = {
        request: {
          body: {
            testParam: 100,
          },
        },
      };

      validator(ctx, () => {});

      ctx
        .check('testParam', 'Default Message')
        .test()
        .withMessage('Custom Message');

      verify(done, () =>
        ctx.validationErrors().catch(() => {
          expect.fail(
            null,
            null,
            'No errors should have been generated by the test',
          );
        }),
      );
    });

    it('should provide a custom message when a validation fails', done => {
      const validator = require('../src/koa_validator')({ // eslint-disable-line
        customValidators: {
          test() {
            // A dummy failing validator
            return new Promise(resolve => {
              resolve(false);
            });
          },
        },
      });

      const ctx = {
        request: {
          body: {
            testParam: 100,
          },
        },
      };

      validator(ctx, () => {});

      ctx
        .check('testParam', 'Default Message')
        .test()
        .withMessage('Custom Message');

      verify(done, () =>
        ctx.validationErrors().catch(err => {
          expect(err).to.deep.equal([
            {
              msg: 'Custom Message',
              param: 'testParam',
              value: 100,
            },
          ]);
        }),
      );
    });

    it('should provide the default message if it was not the validation to fail', done => {
      const validator = require('../src/koa_validator')({ // eslint-disable-line
        customValidators: {
          pass() {
            return new Promise(resolve => {
              resolve(true);
            });
          },
          fail() {
            return new Promise(resolve => {
              resolve(false);
            });
          },
        },
      });

      const ctx = {
        request: {
          body: {
            testParam: 100,
          },
        },
      };

      validator(ctx, () => {});

      ctx
        .check('testParam', 'Default Message')
        .fail() // Default Message
        .pass()
        .withMessage('Passing Message')
        .fail() // Default Message
        .fail()
        .withMessage('Failing Message')
        .fail() // Default Message
        .fail()
        .withMessage('Failing Message 1')
        .fail()
        .withMessage('Failing Message 2');

      const expected = [
        'Default Message',
        'Default Message',
        'Failing Message',
        'Default Message',
        'Failing Message 1',
        'Failing Message 2',
      ];

      verify(done, () =>
        ctx.validationErrors().catch(err => {
          expect(err.map(e => e.msg)).to.deep.equal(expected);
        }),
      );
    });
  });
});
